# Fully Portable PIM-Based Design

The Platform Interface Manager (PIM) abstraction layer is embedded within the FIM build flow. The PIM is always available, whether or not an AFU uses it. The PIM has two major components: a stylized encoding of all incoming platform device wires and a collection of modules for transforming platform-specific FIM interfaces to platform-independent PIM interfaces. Fully portable AFUs use both components.

In this design pattern, an AFU's top-level interface is always:

```SystemVerilog
module ofs_plat_afu
   (
    // All platform wires, wrapped in one interface.
    ofs_plat_if plat_ifc
    );
```

The module name is always *ofs\_plat\_afu* and there is always a single *ofs\_plat\_if* wrapper interface, named *plat\_ifc*. The actual contents of *plat\_ifc* are platform-specific, generated by PIM scripts at FIM build time, but standard naming conventions enable portability. The interfaces to the controlling host are always named *plat\_ifc.host_chan.ports\[\*\]*, independent of whether they are PCIe channels, AXI-MM CSR interfaces, or something else. Consistently named modules are always present for mapping a host channel to either AXI-MM or Avalon-MM CSR and DMA interfaces.

The *ofs\_plat\_if* interface is constructed by PIM scripts and varies depending on the devices available on the platform. Connections to a host are always called *host\_channel*, connections to local DDR or HBM are called *local\_memory*. The interface is stored in ofs\_plat\_if.sv in the tree to which $OPAE\_PLATFORM\_ROOT points. For example, a system with one PCIe channel and some banks of DDR has:

```SystemVerilog
interface ofs_plat_if#(parameter ENABLE_LOG = 0);
    // Required: platform top-level clocks
    wire t_ofs_plat_std_clocks clocks;

    // Required: active low soft reset (clocked by pClk). This reset
    // is identical to clocks.pClk.reset_n.
    logic softReset_n;

    // Wrapper around a vector of one or more host channels, such as PCIe
    ofs_plat_host_chan_fiu_if#(.ENABLE_LOG(ENABLE_LOG)) host_chan();

    // Wrapper around a vector of one or more local memory banks
    ofs_plat_local_mem_fiu_if #(.ENABLE_LOG(ENABLE_LOG)) local_mem();
endinterface // ofs_plat_if
```

Portability is achieved by providing modules with consistent names and semantics that consume device-specific interfaces from *ofs\_plat\_if*. For example, AFUs can depend on a PIM module named *ofs\_plat\_host\_chan\_as\_axi\_mem\(\)* always being available that transforms *plat\_ifc.host_chan.ports\[0\]* to AXI-MM, independent of the host channel's underlying protocol. The examples outlined below provide concrete examples of these transformations.

## Topics

The README file in each subtree describes the implementation. Sources in the subtrees are heavily commented. Most of the commentary on writing RTL and interfaces is embedded in the RTL and C code.

1. [hello\_world](hello_world/) describes the basic structure of an AFU, simulation with ASE and synthesis for hardware. It also covers the AXI, Avalon and CCI-P host interface options available through the PIM. __This section is a prerequisite for all subsequent sections. All of the later examples are compiled using the steps described here.__

2. [local\_memory](local_memory/) covers the top-level interface to local memory, including an introduction to clock management.

3. [clocks](clocks/) documents the global clocks passed into AFUs and PIM-based clock management.

4. [PIM\_advanced](PIM_advanced/) introduces some more PIM features, including parameterization, fences and atomics.

5. [copy\_engine](copy_engine/) is a far more complicated example that puts together many of the concepts covered in the simple examples. It implements a pipelined engine that takes commands from a host application to move data between host memory pages through the FPGA. The data passes through an FPGA module that could perform some transformation before writing to the host.
